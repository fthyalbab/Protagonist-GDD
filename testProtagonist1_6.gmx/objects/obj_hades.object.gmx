<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_fire1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-300</depth>
  <persistent>0</persistent>
  <parentName>obj_parentNPC</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/////Setup Code
/// - Savvy
//Unique variables (change with each child)(single speaker):
speakers = 1; //how many characters will be speaking (1. Object, 2. Protagonist, 3. Anyone else)
numMessages = 2; //Number of possible dialouge choices (if some are hidden, put if statements while drawing?)
talkSprite = spr_defaultSpeak; //Talk sprite to be used for the text
talkSpriteLite = spr_defaultSpeak; //Talk sprite to be used for the text
talkImage = 0; //current frame of the talk sprite above, used in draw
deFont = fnt_default; //used font
textColor = c_yellow; 
textBoxColor = c_black;

//write your messages in an array, starting at 0, like so
//Character 1
message[0] = "Savvy: This is a test code for the mobile NPCs";
message[1] = "Savvy: are seeing this then I messed up - Love, Tech Savvy";

//if multiple speakers
talkSprite2 = spr_defaultSpeak; //Talk sprite to be used for the text (speaker 2)
talkImage2 = 0; //current frame of the talk sprite above, used in draw (speaker 2)
deFont2 = fnt_default; //used font (speaker 2)
textColor2 = c_yellow; 
textBoxColor2 = c_black;

talkSprite3 = spr_defaultSpeak; //Talk sprite to be used for the text (speaker 3)
talkImage3 = 0; //current frame of the talk sprite above, used in draw (speaker 3)
deFont3 = fnt_default; //used font (speaker 3)
textColor3 = c_yellow; 
textBoxColor3 = c_black;

//Controls for other methods:
intDelay = 0; //Delays the start of the text
timeSpeak = 0; //Keeps track of what frame the talk sprite is on
timeSpeakMax = 7; //How many steps before the talk sprite frame changes (default = 7)
talking = false; //checks to see whether it should run the graphics for the textbox and words
axisHit = false; //used for checking near collisions
hit = false; //used for checking near collisions
timer = 0; //Used for delaying between 'f' interactions
countdown = false; //Used for delaying between 'f' interactions
upbox = false; //always draws the textbox in the upper area
downbox = false; //always draws the textbox in the lower area
message_current = 0; //0 is the first number in our array, and the message we are currently at
message_end = numMessages-1; //the last number in our array
message_draw = ""; //this is what we 'write' out. It's blank right now
increase = 0.5; //the speed at which new characters are added
characters = 0; //how many characters have already been drawn
hold = 0; //if we hold 'Z', the text will render faster
startAni = true; //starts the opening animation for moving sprites into place
rotNum = 70;

//Unique variables (change with each child):
currentSprite = ""; //don't remember ??? what is this
message_end = 1; //Number of possible dialouge choices (if some are hidden, put if statements while drawing?)
talkSprite = spr_talkHades; //Talk sprite to be used for the text
talkSpriteLite = spr_talkHadesLite;
deFont = fnt_Hades; //used font
textColor = c_white; 
textBoxColor = c_black;
message[0] = "Blah blah narration etc gotta keep this short.";
message[1] = "I'll be taking this. Bye!";
finishedString = "";
showWorld = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup New Line Divider

for (i = 0; i&lt;=message_end; i++){ //for each message...
   for (j = 0; j &lt; string_length(message[i]); j++){ //for each character...
         if (j mod 100 == 0 &amp;&amp; j != 0){ //For every 30 characters...
          finishedString += "#"; //Add a new line
        }
        finishedString += string_char_at(message[i], j+1); //Then add/ the next char as usual
        //*Debug*/show_message(finishedString);   //^^^^ INDEX STARTS AT 1 FOR THIS METHOD
        //*Debug*/show_message(j); j is climbing properly  
   }
    message[i] = finishedString; //Return the new nice string to replace the old one
    finishedString = ""; //Reset the finished string
}

//*Debug*/show_message(message_current);
message_length = string_length(message[message_current]); //get the number of characters in the first message


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>talking</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sets 'Typewriter' Messaging for the Draw Method ///////////////////////
         //CALLED BY THE 'F' Function  
                   
        /// IF ONLY ONE CHARACTER SPEAKING                    
 if (speakers = 1){                  
     if (characters &lt; message_length) { //if current character count is less than the amount in current message* 
            hold = keyboard_check(ord("F")); //hold is true or false if we hold 'F' or not
            characters += increase * (1 + hold); //increase speed based on hold (remember true is 1)
            message_draw = string_copy(message[message_current], 0, characters); //copy string to current character
        } 
        else { //if current character is more than the amount in the current message
            talkImage = 0; //stop frames on talk sprite
            if (keyboard_check_pressed(ord("F"))) { //if we press F...
                if (message_current &lt; message_end) { //if there are more messages left to show (0 -&gt; 6, in our case)
                    if(message_current == 0){
                    showWorld = true;
                    }
                    message_current += 1; //increase the message by 1
                    message_length = string_length(message[message_current]);  //get the new character length for message
                    characters = 0; //set the characters back to 0
                    message_draw = ""; //clear the drawn text
                }
                else { //if our messages are done (we reach 6, in our case)...
                    //talking = false; //finish drawing events
                   message_current = 0; //reset the message list so it can loop (modify!)
                   characters = 0; //maybe works
                   message_draw = ""; //reset the drawn image (rectangle will stay the same)
                   countdown = true; //starts timer
                   intDelay = 0; //reset the delay for next interaction
                   //obj_protagonist.canMove = true;
                   obj_mouse.hadesControl = true;
                   startAni = true;
                    }
                }
            }
    }
    
    ////////////// IF MORE THAN ONE CHARACTER ///////////////
    
    if (speakers &gt; 1){                  
        if (characters &lt; message_length) { //if current character count is less than the amount in current message* 
            hold = keyboard_check(ord("F")); //hold is true or false if we hold 'F' or not
            characters += increase * (1 + hold); //increase speed based on hold (remember true is 1)
            message_draw = string_copy(message[message_current], 0, characters); //copy string to current character
        } 
        else { //if current character is more than the amount in the current message
            talkImage = 0; //stop frames on talk sprite
            if (keyboard_check_pressed(ord("F"))) { //if we press F...
                if (message_current &lt; message_end) { //if there are more messages left to show (0 -&gt; 6, in our case)
                    message_current += 1; //increase the message by 1
                    message_length = string_length(message[message_current]);  //get the new character length for message
                    characters = 0; //set the characters back to 0
                    message_draw = ""; //clear the drawn text
                }
                else { //if our messages are done (we reach 6, in our case)...
                   //talking = false; //finish drawing events
                   message_current = 0; //reset the message list so it can loop (modify!)
                   characters = 0; //maybe works
                   message_draw = ""; //reset the drawn image (rectangle will stay the same)
                   countdown = true; //starts timer
                   intDelay = 0; //reset the delay for next interaction
                   //obj_protagonist.canMove = true;
                   obj_mouse.hadesControl = true;
                   startAni = true;
                    }
                }
            }
       }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Prevent stacking of dialouge when closing the textbox window

if (countdown == true){
    timer++;
    if (timer &gt;= 9){
        timer = 0;
        countdown = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>talking</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw textbox in right spot (bottom of screen for default, top if it would block something)


//// DRAW THE OPENING ANIMATION
draw_set_colour(textBoxColor);
if (startAni == true){
    //show_message(rotNum);
    if (rotNum!=0){
        //draw normal
         draw_set_colour(textBoxColor);
        tempDepth = depth;
        depth = -290;
        
        ///INITIAL 
        if (rotNum&gt;35) {   
            draw_sprite_ext( talkSpriteLite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum-35, textBoxColor, 0.1);
        }
        else{
            draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, 0, c_white, 0.1);
        }
        
        //TEST
        if (rotNum&gt;28) {   
            draw_sprite_ext( talkSpriteLite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum-28, textBoxColor, 0.2);
        }
        else{
            draw_sprite_ext(talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, 0, c_white, 0.2);
        }
        
        if (rotNum&gt;21) {   
            draw_sprite_ext( talkSpriteLite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum-21, textBoxColor, 0.3);
        }
        else{
            draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, 0, c_white, 0.3);
        }
        
        if (rotNum&gt;14) {   
            draw_sprite_ext(talkSpriteLite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum-14, textBoxColor, 0.4);
        }
        else{
            draw_sprite_ext(talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, 0, c_white, 0.4);
        }
        
        if (rotNum&gt;7) {   
            draw_sprite_ext(talkSpriteLite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum-7, textBoxColor, 0.4);
        }
        else{
            draw_sprite_ext(talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, 0, c_white, 0.5);
        }
        
        depth = -300;
         draw_rectangle(0, room_height, room_width, room_height-200/(rotNum/7), false);
        ///END TEST
        
        //draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40, 1, 1, rotNum, c_white, 1);   
        //draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+(70+rotNum*2), 1, 1, rotNum, c_black, 0.1)
        
        
        /**if (rotNum&gt;=14) {   
        draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+(70+rotNum*2), 1, 1, rotNum-14, c_black, 0.4);
        draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+(70+rotNum*2), 1, 1, rotNum-14, c_white, 0.3);
        }**/
        rotNum-=7;
        depth = tempDepth;
    }
    else{
     draw_sprite_ext( talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+(70+rotNum*2), 1, 1, rotNum, c_white, 1); 
     startAni = false;
     rotNum = 70;
     draw_rectangle(0, room_height, room_width, room_height-(200), false);
     //show_message("Well it turned off?");
    }
}


//// DRAW THE NORMAL SPRITES


else{
    //Check if protagonist or object are in the default textbox area or if upbox or downbox is on
   /** if (((y+sprite_get_height(sprite_index))&gt;=room_height-200 || (obj_protagonist.y+sprite_get_height(object_get_sprite(obj_protagonist)))&gt;= (room_height-200) || upbox == true) &amp;&amp; downbox == false){
        //This is the revised location
        tempDepth = depth;
        depth = -30;
        draw_set_colour(textBoxColor);
        draw_rectangle(0, 0, room_width, 200, false);
        draw_rectangle(room_width/2, 0, room_width, 200, false); //small place for talksprite to sit
        draw_set_colour(textColor);
        draw_set_font(deFont); 
        draw_text(10, 10, message_draw); //draw the text at the coordinates
        draw_sprite(talkSprite, talkImage, room_width-sprite_get_width(talkSprite), room_height-sprite_get_height(talkSprite));
        depth = tempDepth;
    }
    else{**/
        //This is the default location
        //show_message("Hades is present");
        tempDepth = depth;
        depth = -30;
        draw_set_colour(textBoxColor);
        draw_rectangle(0, room_height, room_width, room_height-200, false);
        draw_set_colour(textColor);
        draw_set_font(deFont);
        draw_text(10, room_height-190, message_draw); //draw the text at the coordinates
        draw_sprite(talkSprite, talkImage, room_width-sprite_get_width(talkSprite)/2, room_height+40);
        depth = tempDepth;
      //}
      
      if (timeSpeak == timeSpeakMax){
       talkImage++; //changes the talk sprite frame
       timeSpeak = 0;
       }
     timeSpeak++; //adds one to the animation timer
      
      //And if one is in that area and the other isn't... probably best just to move on
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
